<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>华谊兄弟电影世界</title>
    <link href="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/"/>
    <url>/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<center>憨憨和derder</center><p><img src="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/1.jpg"><img src="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/2.jpg"><img src="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/3.jpg"><img src="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/4.jpg"><img src="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/5.jpg"><img src="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/6.jpg"><img src="/2020/08/04/%E5%8D%8E%E8%B0%8A%E5%85%84%E5%BC%9F%E7%94%B5%E5%BD%B1%E4%B8%96%E7%95%8C/7.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerCompose详解</title>
    <link href="/2020/03/04/DockerCompose%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/03/04/DockerCompose%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Docker-Compose简介"><a href="#一、Docker-Compose简介" class="headerlink" title="一、Docker-Compose简介"></a>一、Docker-Compose简介</h2><h3 id="1、Docker-Compose简介"><a href="#1、Docker-Compose简介" class="headerlink" title="1、Docker-Compose简介"></a>1、Docker-Compose简介</h3><ul><li>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</li><li>前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知</li><li><strong>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</strong></li></ul><h3 id="2、Docker-Compose安装"><a href="#2、Docker-Compose安装" class="headerlink" title="2、Docker-Compose安装"></a>2、Docker-Compose安装</h3><p>安装方法一：<br>下载Docker-Compose：</p><pre><code class="hljs awk">sudo curl -L https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/</span>compose<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/1.23.0-rc3/</span>docker-compose-`uname -s`-`uname -m` -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose</code></pre><p>安装Docker-Compose：<br><code>sudo chmod +x /usr/local/bin/docker-compose</code><br>查看版本 :<br><code>docker-compose version</code><br>安装方法二：<br>安装pip</p><pre><code class="hljs sql">yum -y <span class="hljs-keyword">install</span> epel-<span class="hljs-keyword">release</span>yum -y <span class="hljs-keyword">install</span> python-pip</code></pre><p>确认版本<br><code>pip --version</code><br>更新pip<br><code>pip install --upgrade pip</code><br>安装docker-compose<br><code>pip install docker-compose</code><br>查看版本<br><code>docker-compose version</code><br>安装补全工具：<br>为了方便输入命令，也可以安装Docker的补全提示工具帮忙快速输入命令：<br>安装<br><code>yum install bash-completion</code><br>下载docker-compose脚本</p><pre><code class="hljs awk">curl -L https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/docker/</span>compose<span class="hljs-regexp">/$(docker-compose version --short)/</span>contrib<span class="hljs-regexp">/completion/</span>bash<span class="hljs-regexp">/docker-compose &gt; /</span>etc<span class="hljs-regexp">/bash_completion.d/</span>docker-compose</code></pre><h3 id="3、Docker-Compose卸载"><a href="#3、Docker-Compose卸载" class="headerlink" title="3、Docker-Compose卸载"></a>3、Docker-Compose卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可：<br><code>sudo rm /usr/local/bin/docker-compose</code><br>如果通过Python pip工具安装的，则执行如下命令删除：<br><code>sudo pip uninstall docker-compose</code></p><h2 id="二、Docker-Compose常用命令"><a href="#二、Docker-Compose常用命令" class="headerlink" title="二、Docker-Compose常用命令"></a>二、Docker-Compose常用命令</h2><h3 id="1、Docker-Compose命令格式"><a href="#1、Docker-Compose命令格式" class="headerlink" title="1、Docker-Compose命令格式"></a>1、Docker-Compose命令格式</h3><pre><code class="hljs css"><span class="hljs-selector-tag">docker-compose</span> <span class="hljs-selector-attr">[-f &lt;arg&gt;...]</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARGS...]</span></code></pre><p>命令选项如下：<br>-f，–file FILE指定Compose模板文件，默认为docker-compose.yml，可以多次指定。<br>-p，–project-name NAME指定项目名称，默认将使用所在目录名称作为项目名。<br>-x-network-driver 使用Docker的可拔插网络后端特性（需要Docker 1.9+版本）<br>-x-network-driver DRIVER指定网络后端的驱动，默认为bridge（需要Docker 1.9+版本）<br>-verbose输出更多调试信息<br>-v，–version打印版本并退出</p><h3 id="2、docker-compose-up"><a href="#2、docker-compose-up" class="headerlink" title="2、docker-compose up"></a>2、docker-compose up</h3><pre><code class="hljs css"><span class="hljs-selector-tag">docker-compose</span> <span class="hljs-selector-tag">up</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[--scale SERVICE=NUM...]</span> <span class="hljs-selector-attr">[SERVICE...]</span></code></pre><p>选项包括：<br>-d 在后台运行服务容器<br>–no-color 不使用颜色来区分不同的服务的控制输出<br>–no-deps 不启动服务所链接的容器<br>–force-recreate 强制重新创建容器，不能与–no-recreate同时使用<br>–no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用<br>–no-build 不自动构建缺失的服务镜像<br>–build 在启动容器前构建服务镜像<br>–abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用<br>-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）<br>–remove-orphans 删除服务中没有在compose文件中定义的容器<br>–scale SERVICE=NUM 设置服务运行容器的个数，将覆盖在compose中通过scale指定的参数<br><code>docker-compose up</code><br>启动所有服务<br><code>docker-compose up -d</code><br>在后台所有启动服务<br>-f 指定使用的Compose模板文件，默认为docker-compose.yml，可以多次指定。<br><code>docker-compose -f docker-compose.yml up -d</code></p><h3 id="3、docker-compose-ps"><a href="#3、docker-compose-ps" class="headerlink" title="3、docker-compose ps"></a>3、docker-compose ps</h3><p><code>docker-compose ps [options] [SERVICE...]</code><br><code>docker-compose ps</code><br>列出项目中目前的所有容器</p><h3 id="4、docker-compose-stop"><a href="#4、docker-compose-stop" class="headerlink" title="4、docker-compose stop"></a>4、docker-compose stop</h3><p><code>docker-compose stop [options] [SERVICE...]</code><br>选项包括：<br>-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）<br><code>docker-compose stop</code><br>停止正在运行的容器，可以通过docker-compose start 再次启动</p><h3 id="5、docker-compose-h"><a href="#5、docker-compose-h" class="headerlink" title="5、docker-compose -h"></a>5、docker-compose -h</h3><p><code>docker-compose -h</code><br>查看帮助</p><h3 id="6、docker-compose-down"><a href="#6、docker-compose-down" class="headerlink" title="6、docker-compose down"></a>6、docker-compose down</h3><p><code>docker-compose down [options]</code><br>停止和删除容器、网络、卷、镜像。<br>选项包括：<br>–rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像<br>-v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷<br>–remove-orphans，删除服务中没有在compose中定义的容器<br><code>docker-compose down</code><br>停用移除所有容器以及网络相关</p><h3 id="7、docker-compose-logs"><a href="#7、docker-compose-logs" class="headerlink" title="7、docker-compose logs"></a>7、docker-compose logs</h3><p><code>docker-compose logs [options] [SERVICE...]</code><br>查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。<br><code>docker-compose logs</code><br>查看服务容器的输出</p><h3 id="8、docker-compose-build"><a href="#8、docker-compose-build" class="headerlink" title="8、docker-compose build"></a>8、docker-compose build</h3><p><code>docker-compose build [options] [--build-arg key=val...] [SERVICE...]</code><br>构建（重新构建）项目中的服务容器。<br>选项包括：<br>–compress 通过gzip压缩构建上下环境<br>–force-rm 删除构建过程中的临时容器<br>–no-cache 构建镜像过程中不使用缓存<br>–pull 始终尝试通过拉取操作来获取更新版本的镜像<br>-m, –memory MEM为构建的容器设置内存大小<br>–build-arg key=val为服务设置build-time变量<br>服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务</p><h3 id="9、docker-compose-pull"><a href="#9、docker-compose-pull" class="headerlink" title="9、docker-compose pull"></a>9、docker-compose pull</h3><p><code>docker-compose pull [options] [SERVICE...]</code><br>拉取服务依赖的镜像。<br>选项包括：<br>–ignore-pull-failures，忽略拉取镜像过程中的错误<br>–parallel，多个镜像同时拉取<br>–quiet，拉取镜像过程中不打印进度信息<br><code>docker-compose pull</code><br>拉取服务依赖的镜像</p><h3 id="10、docker-compose-restart"><a href="#10、docker-compose-restart" class="headerlink" title="10、docker-compose restart"></a>10、docker-compose restart</h3><p><code>docker-compose restart [options] [SERVICE...]</code><br>重启项目中的服务。<br>选项包括：<br>-t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒）<br><code>docker-compose restart</code><br>重启项目中的服务</p><h3 id="11、docker-compose-rm"><a href="#11、docker-compose-rm" class="headerlink" title="11、docker-compose rm"></a>11、docker-compose rm</h3><p><code>docker-compose rm [options] [SERVICE...]</code><br>删除所有（停止状态的）服务容器。<br>选项包括：<br>–f, –force，强制直接删除，包括非停止状态的容器<br>-v，删除容器所挂载的数据卷<br><code>docker-compose rm</code><br>删除所有（停止状态的）服务容器。推荐先执行docker-compose stop命令来停止容器。</p><h3 id="12、docker-compose-start"><a href="#12、docker-compose-start" class="headerlink" title="12、docker-compose start"></a>12、docker-compose start</h3><p><code>docker-compose start [SERVICE...]</code><br><code>docker-compose start</code><br>启动已经存在的服务容器。</p><h3 id="13、docker-compose-run"><a href="#13、docker-compose-run" class="headerlink" title="13、docker-compose run"></a>13、docker-compose run</h3><p><code>docker-compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code><br>在指定服务上执行一个命令。<br><code>docker-compose run ubuntu ping www.baidu.com</code><br>在指定容器上执行一个ping命令。</p><h3 id="14、docker-compose-scale"><a href="#14、docker-compose-scale" class="headerlink" title="14、docker-compose scale"></a>14、docker-compose scale</h3><p><code>docker-compose scale web=3 db=2</code><br>设置指定服务运行的容器个数。通过service=num的参数来设置数量</p><h3 id="15、docker-compose-pause"><a href="#15、docker-compose-pause" class="headerlink" title="15、docker-compose pause"></a>15、docker-compose pause</h3><p><code>docker-compose pause [SERVICE...]</code><br>暂停一个服务容器</p><h3 id="16、docker-compose-kill"><a href="#16、docker-compose-kill" class="headerlink" title="16、docker-compose kill"></a>16、docker-compose kill</h3><p><code>docker-compose kill [options] [SERVICE...]</code><br>通过发送SIGKILL信号来强制停止服务容器。<br>支持通过-s参数来指定发送的信号，例如通过如下指令发送SIGINT信号：<br><code>docker-compose kill -s SIGINT</code></p><h3 id="17、dokcer-compose-config"><a href="#17、dokcer-compose-config" class="headerlink" title="17、dokcer-compose config"></a>17、dokcer-compose config</h3><p><code>docker-compose config [options]</code><br>验证并查看compose文件配置。<br>选项包括：<br>–resolve-image-digests 将镜像标签标记为摘要<br>-q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息<br>–services 打印服务名，一行一个<br>–volumes 打印数据卷名，一行一个</p><h3 id="18、docker-compose-create"><a href="#18、docker-compose-create" class="headerlink" title="18、docker-compose create"></a>18、docker-compose create</h3><p><code>docker-compose create [options] [SERVICE...]</code><br>为服务创建容器。<br>选项包括：<br>–force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数<br>–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数<br>–no-build：不创建镜像，即使缺失<br>–build：创建容器前，生成镜像</p><h3 id="19、docker-compose-exec"><a href="#19、docker-compose-exec" class="headerlink" title="19、docker-compose exec"></a>19、docker-compose exec</h3><p><code>docker-compose exec [options] SERVICE COMMAND [ARGS...]</code><br>选项包括：<br>-d 分离模式，后台运行命令。<br>–privileged 获取特权。<br>–user USER 指定运行的用户。<br>-T 禁用分配TTY，默认docker-compose exec分配TTY。<br>–index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index=1 web /bin/bash ，web服务中包含多个容器</p><h3 id="20、docker-compose-port"><a href="#20、docker-compose-port" class="headerlink" title="20、docker-compose port"></a>20、docker-compose port</h3><p><code>docker-compose port [options] SERVICE PRIVATE_PORT</code><br>显示某个容器端口所映射的公共端口。<br>选项包括：<br>–protocol=proto，指定端口协议，TCP（默认值）或者UDP<br>–index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）</p><h3 id="21、docker-compose-push"><a href="#21、docker-compose-push" class="headerlink" title="21、docker-compose push"></a>21、docker-compose push</h3><p><code>docker-compose push [options] [SERVICE...]</code><br>推送服务依的镜像。<br>选项包括：<br>–ignore-push-failures 忽略推送镜像过程中的错误</p><h3 id="22、docker-compose-stop"><a href="#22、docker-compose-stop" class="headerlink" title="22、docker-compose stop"></a>22、docker-compose stop</h3><p><code>docker-compose stop [options] [SERVICE...]</code><br>显示各个容器运行的进程情况。</p><h3 id="23、docker-compose-unpause"><a href="#23、docker-compose-unpause" class="headerlink" title="23、docker-compose unpause"></a>23、docker-compose unpause</h3><p><code>docker-compose unpause [SERVICE...]</code><br>恢复处于暂停状态中的服务。</p><h3 id="24、docker-compose-version"><a href="#24、docker-compose-version" class="headerlink" title="24、docker-compose version"></a>24、docker-compose version</h3><p><code>docker-compose version</code><br>打印版本信息。</p><h2 id="三、Docker-Compose模板文件"><a href="#三、Docker-Compose模板文件" class="headerlink" title="三、Docker-Compose模板文件"></a>三、Docker-Compose模板文件</h2><h3 id="1、Docker-Compose模板文件简介"><a href="#1、Docker-Compose模板文件简介" class="headerlink" title="1、Docker-Compose模板文件简介"></a>1、Docker-Compose模板文件简介</h3><p>Compose允许用户通过一个docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。<br>Compose模板文件是一个定义服务、网络和卷的YAML文件。Compose模板文件默认路径是当前目录下的docker-compose.yml，可以使用.yml或.yaml作为文件扩展名。<br>Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。</p><pre><code class="hljs less"><span class="hljs-attribute">version</span>: <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-attribute">services</span>:  <span class="hljs-attribute">web</span>:    <span class="hljs-attribute">image</span>: dockercloud/hello-world    <span class="hljs-attribute">ports</span>:      - <span class="hljs-number">8080</span>    <span class="hljs-attribute">networks</span>:      - front-tier      - back-tier  <span class="hljs-attribute">redis</span>:    <span class="hljs-attribute">image</span>: redis    <span class="hljs-attribute">links</span>:      - web    <span class="hljs-attribute">networks</span>:      - back-tier  <span class="hljs-attribute">lb</span>:    <span class="hljs-attribute">image</span>: dockercloud/haproxy    <span class="hljs-attribute">ports</span>:      - <span class="hljs-number">80</span>:<span class="hljs-number">80</span>    <span class="hljs-attribute">links</span>:      - web    <span class="hljs-attribute">networks</span>:      - front-tier      - back-tier    <span class="hljs-attribute">volumes</span>:      - /var/run/docker.<span class="hljs-attribute">sock</span>:/var/run/docker.sock <span class="hljs-attribute">networks</span>:  <span class="hljs-attribute">front-tier</span>:    <span class="hljs-attribute">driver</span>: bridge  <span class="hljs-attribute">back-tier</span>:    <span class="hljs-attribute">driver</span>: bridge</code></pre><p>Compose目前有三个版本分别为Version 1，Version 2，Version 3，Compose区分Version 1和Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2支持更多的指令。Version 1将来会被弃用。</p><h3 id="2、image"><a href="#2、image" class="headerlink" title="2、image"></a>2、image</h3><p>image是指定服务的镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像。</p><pre><code class="hljs dts"><span class="hljs-symbol">services:</span> <span class="hljs-symbol">    web:</span> <span class="hljs-symbol">        image:</span> hello-world</code></pre><h3 id="3、build"><a href="#3、build" class="headerlink" title="3、build"></a>3、build</h3><p>服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。Compose将会利用Dockerfile自动构建镜像，然后使用镜像启动服务容器。<br><code>build: /path/to/build/dir</code><br>也可以是相对路径，只要上下文确定就可以读取到Dockerfile。<br><code>build: ./dir</code><br>设定上下文根目录，然后以该目录为准指定Dockerfile。</p><pre><code class="hljs dts"><span class="hljs-symbol">build:</span><span class="hljs-symbol">  context:</span> ../<span class="hljs-symbol">  dockerfile:</span> path<span class="hljs-meta-keyword">/of/</span>Dockerfile</code></pre><p>build都是一个目录，如果要指定Dockerfile文件需要在build标签的子级标签中使用dockerfile标签指定。<br>如果同时指定image和build两个标签，那么Compose会构建镜像并且把镜像命名为image值指定的名字。</p><h3 id="4、context"><a href="#4、context" class="headerlink" title="4、context"></a>4、context</h3><p>context选项可以是Dockerfile的文件路径，也可以是到链接到git仓库的url，当提供的值是相对路径时，被解析为相对于撰写文件的路径，此目录也是发送到Docker守护进程的context</p><pre><code class="hljs dts"><span class="hljs-symbol">build:</span><span class="hljs-symbol">  context:</span> ./dir</code></pre><h3 id="5、dockerfile"><a href="#5、dockerfile" class="headerlink" title="5、dockerfile"></a>5、dockerfile</h3><p>使用dockerfile文件来构建，必须指定构建路径</p><pre><code class="hljs dts"><span class="hljs-symbol">build:</span><span class="hljs-symbol">  context:</span> .<span class="hljs-symbol">  dockerfile:</span> Dockerfile-alternate</code></pre><p>dockerfile指令不能跟image同时使用，否则Compose将不确定根据哪个指令来生成最终的服务镜像。</p><h3 id="6、command"><a href="#6、command" class="headerlink" title="6、command"></a>6、command</h3><p>使用command可以覆盖容器启动后默认执行的命令。<br><code>command: bundle exec thin -p 3000</code></p><h3 id="7、container-name"><a href="#7、container-name" class="headerlink" title="7、container_name"></a>7、container_name</h3><p>Compose的容器名称格式是：&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt;<br>可以自定义项目名称、服务名称，但如果想完全控制容器的命名，可以使用标签指定：<br><code>container_name: app</code></p><h3 id="8、depends-on"><a href="#8、depends-on" class="headerlink" title="8、depends_on"></a>8、depends_on</h3><p>在使用Compose时，最大的好处就是少打启动命令，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没启动数据库容器的时候启动应用容器，应用容器会因为找不到数据库而退出。depends_on标签用于解决容器的依赖、启动先后的问题。</p><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-symbol">services:</span><span class="hljs-symbol">  web:</span><span class="hljs-symbol">    build:</span> .<span class="hljs-symbol">    depends_on:</span>      - db      - redis<span class="hljs-symbol">  redis:</span><span class="hljs-symbol">    image:</span> redis<span class="hljs-symbol">  db:</span><span class="hljs-symbol">    image:</span> postgres</code></pre><p>上述YAML文件定义的容器会先启动redis和db两个服务，最后才启动web 服务。</p><h3 id="9、pid"><a href="#9、pid" class="headerlink" title="9、pid"></a>9、pid</h3><p><code>pid: &quot;host&quot;</code><br>将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用pid标签将能够访问和操纵其他容器和宿主机的名称空间。</p><h3 id="10、ports"><a href="#10、ports" class="headerlink" title="10、ports"></a>10、ports</h3><p>ports用于映射端口的标签。<br>使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。</p><pre><code class="hljs haml">ports: -<span class="ruby"> <span class="hljs-string">&quot;3000&quot;</span></span><span class="ruby"> - <span class="hljs-string">&quot;8000:8000&quot;</span></span><span class="ruby"> - <span class="hljs-string">&quot;49100:22&quot;</span></span><span class="ruby"> - <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span></span></code></pre><p>当使用HOST:CONTAINER格式来映射端口时，如果使用的容器端口小于60可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。</p><h3 id="11、extra-hosts"><a href="#11、extra-hosts" class="headerlink" title="11、extra_hosts"></a>11、extra_hosts</h3><p>添加主机名的标签，会在/etc/hosts文件中添加一些记录。</p><pre><code class="hljs haml">extra_hosts: -<span class="ruby"> <span class="hljs-string">&quot;somehost:162.242.195.82&quot;</span></span><span class="ruby"> - <span class="hljs-string">&quot;otherhost:50.31.209.229&quot;</span></span></code></pre><p>启动后查看容器内部hosts：</p><pre><code class="hljs accesslog"><span class="hljs-number">162.242.195.82</span>  somehost<span class="hljs-number">50.31.209.229</span>   otherhost</code></pre><h3 id="12、volumes"><a href="#12、volumes" class="headerlink" title="12、volumes"></a>12、volumes</h3><p>挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER]格式，或者使用[HOST:CONTAINER:ro]格式，后者对于容器来说，数据卷是只读的，可以有效保护宿主机的文件系统。<br>Compose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。<br>数据卷的格式可以是下面多种形式：</p><pre><code class="hljs awk">volumes:  <span class="hljs-regexp">//</span> 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。  - <span class="hljs-regexp">/var/</span>lib/mysql  <span class="hljs-regexp">//</span> 使用绝对路径挂载数据卷  - <span class="hljs-regexp">/opt/</span>data:<span class="hljs-regexp">/var/</span>lib/mysql  <span class="hljs-regexp">//</span> 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。  - .<span class="hljs-regexp">/cache:/</span>tmp/cache  <span class="hljs-regexp">//</span> 使用用户的相对路径（~<span class="hljs-regexp">/ 表示的目录是 /</span>home<span class="hljs-regexp">/&lt;用户目录&gt;/</span> 或者 <span class="hljs-regexp">/root/</span>）。  - ~<span class="hljs-regexp">/configs:/</span>etc<span class="hljs-regexp">/configs/</span>:ro  <span class="hljs-regexp">//</span> 已经存在的命名的数据卷。  - datavolume:<span class="hljs-regexp">/var/</span>lib/mysql</code></pre><p>如果不使用宿主机的路径，可以指定一个volume_driver。<br><code>volume_driver: mydriver</code></p><h3 id="13、volumes-from"><a href="#13、volumes-from" class="headerlink" title="13、volumes_from"></a>13、volumes_from</h3><p>从另一个服务或容器挂载其数据卷：</p><pre><code class="hljs haml">volumes_from:   -<span class="ruby"> service_name    </span><span class="ruby">     - container_name</span></code></pre><h3 id="14、dns"><a href="#14、dns" class="headerlink" title="14、dns"></a>14、dns</h3><p>自定义DNS服务器。可以是一个值，也可以是一个列表。</p><pre><code class="hljs angelscript">dns：<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>dns：    - <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>          - <span class="hljs-number">9.9</span><span class="hljs-number">.9</span><span class="hljs-number">.9</span></code></pre><h3 id="15、dns-search"><a href="#15、dns-search" class="headerlink" title="15、dns_search"></a>15、dns_search</h3><p>配置DNS搜索域。可以是一个值，也可以是一个列表。</p><pre><code class="hljs css"><span class="hljs-selector-tag">dns_search</span>：<span class="hljs-selector-tag">example</span><span class="hljs-selector-class">.com</span><span class="hljs-selector-tag">dns_search</span>：    <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">domain1</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>    <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">domain2</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span></code></pre><h3 id="16、entrypoint"><a href="#16、entrypoint" class="headerlink" title="16、entrypoint"></a>16、entrypoint</h3><p>在Dockerfile中有一个指令叫做ENTRYPOINT指令，用于指定接入点。<br>在docker-compose.yml中可以定义接入点，覆盖Dockerfile中的定义：<br><code>entrypoint: /code/entrypoint.sh</code></p><h3 id="17、env-file"><a href="#17、env-file" class="headerlink" title="17、env_file"></a>17、env_file</h3><p>在docker-compose.yml中可以定义一个专门存放变量的文件。<br>如果通过docker-compose -f FILE指定配置文件，则env_file中路径会使用配置文件路径。<br>如果有变量名称与environment指令冲突，则以后者为准。格式如下：<br><code>env_file: .env</code><br>或者根据docker-compose.yml设置多个：</p><pre><code class="hljs awk">env_file:  - ./common.env  - .<span class="hljs-regexp">/apps/</span>web.env  - <span class="hljs-regexp">/opt/</span>secrets.env</code></pre><p>如果在配置文件中有build操作，变量并不会进入构建过程中。</p><h3 id="18、cap-add"><a href="#18、cap-add" class="headerlink" title="18、cap_add"></a>18、cap_add</h3><p>增加指定容器的内核能力（capacity）。<br>让容器具有所有能力可以指定：</p><pre><code class="hljs ada">cap_add:    - <span class="hljs-keyword">ALL</span></code></pre><h3 id="19、cap-drop"><a href="#19、cap-drop" class="headerlink" title="19、cap_drop"></a>19、cap_drop</h3><p>去掉指定容器的内核能力（capacity）。<br>去掉NET_ADMIN能力可以指定：</p><pre><code class="hljs avrasm"><span class="hljs-symbol">cap_drop:</span>    - NET_ADMIN</code></pre><h3 id="20、cgroup-parent"><a href="#20、cgroup-parent" class="headerlink" title="20、cgroup_parent"></a>20、cgroup_parent</h3><p>创建了一个cgroup组名称为cgroups_1:<br><code>cgroup_parent: cgroups_1</code></p><h3 id="21、devices"><a href="#21、devices" class="headerlink" title="21、devices"></a>21、devices</h3><p>指定设备映射关系，例如：</p><pre><code class="hljs avrasm"><span class="hljs-symbol">devices:</span>    - <span class="hljs-string">&quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span></code></pre><h3 id="22、expose"><a href="#22、expose" class="headerlink" title="22、expose"></a>22、expose</h3><p>暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：</p><pre><code class="hljs haml">expose:    -<span class="ruby"> <span class="hljs-string">&quot;3000&quot;</span></span><span class="ruby">    - <span class="hljs-string">&quot;8000&quot;</span></span></code></pre><h3 id="23、extends"><a href="#23、extends" class="headerlink" title="23、extends"></a>23、extends</h3><p>基于其它模板文件进行扩展。例如，对于webapp服务定义了一个基础模板文件为common.yml：</p><pre><code class="hljs routeros"><span class="hljs-comment"># common.yml</span>webapp:    build: ./webapp    environment:        - <span class="hljs-attribute">DEBUG</span>=<span class="hljs-literal">false</span>        - <span class="hljs-attribute">SEND_EMAILS</span>=<span class="hljs-literal">false</span></code></pre><p>再编写一个新的development.yml文件，使用common.yml中的webapp服务进行扩展：</p><pre><code class="hljs dts"><span class="hljs-meta"># development.yml</span><span class="hljs-symbol">web:</span><span class="hljs-symbol">    extends:</span><span class="hljs-symbol">        file:</span> common.yml<span class="hljs-symbol">        service:</span> webapp<span class="hljs-symbol">    ports:</span>        - <span class="hljs-string">&quot;8000:8000&quot;</span><span class="hljs-symbol">    links:</span>        - db<span class="hljs-symbol">    environment:</span>        - DEBUG=true<span class="hljs-symbol">db:</span><span class="hljs-symbol">    image:</span> mysql</code></pre><p>后者会自动继承common.yml中的webapp服务及环境变量定义。<br>extends限制如下：<br>A、要避免出现循环依赖<br>B、extends不会继承links和volumes_from中定义的容器和数据卷资源<br>推荐在基础模板中只定义一些可以共享的镜像和环境变量，在扩展模板中具体指定应用变量、链接、数据卷等信息</p><h3 id="24、external-links"><a href="#24、external-links" class="headerlink" title="24、external_links"></a>24、external_links</h3><p>链接到docker-compose.yml外部的容器，可以是非Compose管理的外部容器。</p><pre><code class="hljs groovy"><span class="hljs-attr">external_links:</span>    - redis_1    - <span class="hljs-attr">project_db_1:</span>mysql    - <span class="hljs-attr">project_db_1:</span>postgresql</code></pre><h3 id="25、labels"><a href="#25、labels" class="headerlink" title="25、labels"></a>25、labels</h3><p>为容器添加Docker元数据（metadata）信息。例如，可以为容器添加辅助说明信息：</p><pre><code class="hljs stylus">labels：    com<span class="hljs-selector-class">.startupteam</span><span class="hljs-selector-class">.description</span>: <span class="hljs-string">&quot;webapp for a strtup team&quot;</span></code></pre><h3 id="26、links"><a href="#26、links" class="headerlink" title="26、links"></a>26、links</h3><p>链接到其它服务中的容器。使用服务名称（同时作为别名），或者“服务名称:服务别名”（如 SERVICE:ALIAS），例如：</p><pre><code class="hljs markdown">links:<span class="hljs-bullet">    -</span> db<span class="hljs-bullet">    -</span> db:database<span class="hljs-bullet">    -</span> redis</code></pre><p>使用别名将会自动在服务容器中的/etc/hosts里创建。例如：</p><pre><code class="hljs accesslog"><span class="hljs-number">172.17.2.186</span>  db<span class="hljs-number">172.17.2.186</span>  database<span class="hljs-number">172.17.2.187</span>  redis</code></pre><h3 id="27、log-driver"><a href="#27、log-driver" class="headerlink" title="27、log_driver"></a>27、log_driver</h3><p>指定日志驱动类型。目前支持三种日志驱动类型：</p><pre><code class="hljs avrasm"><span class="hljs-symbol">log_driver:</span> <span class="hljs-string">&quot;json-file&quot;</span><span class="hljs-symbol">log_driver:</span> <span class="hljs-string">&quot;syslog&quot;</span><span class="hljs-symbol">log_driver:</span> <span class="hljs-string">&quot;none&quot;</span></code></pre><h3 id="28、log-opt"><a href="#28、log-opt" class="headerlink" title="28、log_opt"></a>28、log_opt</h3><p>日志驱动的相关参数。例如：</p><pre><code class="hljs groovy"><span class="hljs-attr">log_driver:</span> <span class="hljs-string">&quot;syslog&quot;</span><span class="hljs-attr">log_opt:</span>     syslog-<span class="hljs-attr">address:</span> <span class="hljs-string">&quot;tcp://192.168.0.42:123&quot;</span></code></pre><h3 id="29、net"><a href="#29、net" class="headerlink" title="29、net"></a>29、net</h3><p>设置网络模式。</p><pre><code class="hljs avrasm"><span class="hljs-symbol">net:</span> <span class="hljs-string">&quot;bridge&quot;</span><span class="hljs-symbol">net:</span> <span class="hljs-string">&quot;none&quot;</span><span class="hljs-symbol">net:</span> <span class="hljs-string">&quot;host&quot;</span></code></pre><h3 id="30、security-opt"><a href="#30、security-opt" class="headerlink" title="30、security_opt"></a>30、security_opt</h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如，配置标签的用户名和角色名：</p><pre><code class="hljs groovy"><span class="hljs-attr">security_opt:</span>    - <span class="hljs-attr">label:</span><span class="hljs-attr">user:</span>USER    - <span class="hljs-attr">label:</span><span class="hljs-attr">role:</span>ROLE</code></pre><h3 id="31、环境变量"><a href="#31、环境变量" class="headerlink" title="31、环境变量"></a>31、环境变量</h3><p>环境变量可以用来配置Docker-Compose的行为。<br>COMPOSE_PROJECT_NAME<br>设置通过Compose启动的每一个容器前添加的项目名称，默认是当前工作目录的名字。<br>COMPOSE_FILE<br>设置docker-compose.yml模板文件的路径。默认路径是当前工作目录。<br>DOCKER_HOST<br>设置Docker daemon的地址。默认使用unix:///var/run/docker.sock。 DOCKER_TLS_VERIFY<br>如果设置不为空，则与Docker daemon交互通过TLS进行。<br>DOCKER_CERT_PATH<br>配置TLS通信所需要的验证(ca.pem、cert.pem 和 key.pem)文件的路径，默认是 ~/.docker 。</p><h2 id="四、Docker-Compose模板文件示例"><a href="#四、Docker-Compose模板文件示例" class="headerlink" title="四、Docker-Compose模板文件示例"></a>四、Docker-Compose模板文件示例</h2><h3 id="1、docker-compose模板文件编写"><a href="#1、docker-compose模板文件编写" class="headerlink" title="1、docker-compose模板文件编写"></a>1、docker-compose模板文件编写</h3><p>docker-compose.yaml文件如下：</p><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-symbol">services:</span><span class="hljs-symbol">  web1:</span><span class="hljs-symbol">    image:</span> nginx<span class="hljs-symbol">    ports:</span>       - <span class="hljs-string">&quot;6061:80&quot;</span><span class="hljs-symbol">    container_name:</span> <span class="hljs-string">&quot;web1&quot;</span><span class="hljs-symbol">    networks:</span>      - dev<span class="hljs-symbol">  web2:</span><span class="hljs-symbol">    image:</span> nginx<span class="hljs-symbol">    ports:</span>       - <span class="hljs-string">&quot;6062:80&quot;</span><span class="hljs-symbol">    container_name:</span> <span class="hljs-string">&quot;web2&quot;</span><span class="hljs-symbol">    networks:</span>      - dev      - pro<span class="hljs-symbol">  web3:</span><span class="hljs-symbol">    image:</span> nginx<span class="hljs-symbol">    ports:</span>       - <span class="hljs-string">&quot;6063:80&quot;</span><span class="hljs-symbol">    container_name:</span> <span class="hljs-string">&quot;web3&quot;</span><span class="hljs-symbol">    networks:</span>      - pro<span class="hljs-symbol">networks:</span><span class="hljs-symbol">  dev:</span><span class="hljs-symbol">    driver:</span> bridge<span class="hljs-symbol">  pro:</span><span class="hljs-symbol">    driver:</span> bridge<span class="hljs-meta">#volumes:</span></code></pre><p>docker-compose.yaml文件指定了三个web服务。</p><h3 id="2、启动应用"><a href="#2、启动应用" class="headerlink" title="2、启动应用"></a>2、启动应用</h3><p>创建一个webapp目录，将docker-compose.yaml文件拷贝到webapp目录下，使用docker-compose启动应用。<br><code>docker-compose up -d</code></p><h3 id="3、服务访问"><a href="#3、服务访问" class="headerlink" title="3、服务访问"></a>3、服务访问</h3><p>通过浏览器访问web1，web2，web3服务:<br><a href="http://127.0.0.1:6061/">http://127.0.0.1:6061</a><br><a href="http://127.0.0.1:6062/">http://127.0.0.1:6062</a><br><a href="http://127.0.0.1:6063/">http://127.0.0.1:6063</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DockerCompose详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2020/03/02/docker/"/>
    <url>/2020/03/02/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h2><ol><li><p>Docker 是应用最广泛的开源容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中 </p></li><li><p>然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。 </p></li><li><p>每个容器拥有一套和宿主机完全隔离的文件系统（共用linux内核），程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。 </p><p>容器：</p><p><strong>1）</strong>容器是一个操作系统级别下的虚拟化技术，运行一个容器就行运行一个进程一样</p><p><strong>2）</strong>容器依赖linux内核特性：Namespace（资源隔离）和Cgroups（资源限制）</p></li></ol><p><strong>总结</strong></p><ul><li>一个简单的应用程序打包工具</li><li>使用最广泛的开源容器</li><li>一种操作系统级的虚拟化技术</li><li>依赖于Linux内核特性：Namespace（资源隔离） 和 Cgroups（资源限制）</li></ul><hr><h2 id="二、docker的组成"><a href="#二、docker的组成" class="headerlink" title="二、docker的组成"></a>二、docker的组成</h2><p><img src="/2020/03/02/docker/image1.png"></p><table><thead><tr><th>DockerClient</th><th>客户端</th></tr></thead><tbody><tr><td>Docker Daemon</td><td>守护进程</td></tr><tr><td>Docker Images</td><td>镜像</td></tr><tr><td>Docker Container</td><td>容器</td></tr><tr><td>Docker Registry</td><td>镜像仓库</td></tr></tbody></table><h2 id="三、docker与虚拟机比较"><a href="#三、docker与虚拟机比较" class="headerlink" title="三、docker与虚拟机比较"></a>三、docker与虚拟机比较</h2><p><img src="/2020/03/02/docker/image2.png"></p><p><img src="/2020/03/02/docker/image3.png"></p><h2 id="四、docker技术应用场景"><a href="#四、docker技术应用场景" class="headerlink" title="四、docker技术应用场景"></a>四、docker技术应用场景</h2><h3 id="1、场景一：节省项目环境部署时间"><a href="#1、场景一：节省项目环境部署时间" class="headerlink" title="1、场景一：节省项目环境部署时间"></a><strong>1、场景一：节省项目环境部署时间</strong></h3><p>　　　<strong>1）单项目打包</strong></p><p>　　　　　　1. 每次部署项目到测试、生产等环境，都要部署一大堆依赖的软件、工具，时间久，出错概率大。</p><p>　　　　　　2. Docker主要理念就是环境打包部署，可在任意Docker Engine运行。</p><p>　　　　　　3. 我们只需要将每个项目环境打包到镜像，push到镜像仓库，当有需要部署这个项目时，直接pull镜像启动容器，这个项目就可以访问了！一次构建多次部署，一劳永逸。</p><p>　　　 <strong>2）整套项目打包</strong></p><p>　　　　　　1. 比如有一个产品可以整套部署到客户那里，以往都是派一名实施工程师到客户那部署。</p><p>　　　　　　2. 如果用了Docker，我们可以前期将这套项目封装打包起来，实现一键部署，分分钟钟搞定，就不需要再派人过去了。比如官方的Docker Compose编排工具。</p><p>　　　 <strong>3）新开源技术试用</strong></p><p>　　　　　　1. 有时，我们想调研一些开源项目，我们可以直接从公共镜像仓库pull项目官方做好镜像启动容器即可。</p><h3 id="2、场景二：环境一致性"><a href="#2、场景二：环境一致性" class="headerlink" title="2、场景二：环境一致性"></a><strong>2、场景二：环境一致性</strong></h3><p>　　　　　　1. 项目在开发电脑本地运行没问题，到了测试或生产环境就运行不起来。</p><p>　　　　　　2. Docker将项目环境打包成镜像，可以在任何Docker Engine部署。</p><h3 id="3、场景三：持续集成"><a href="#3、场景三：持续集成" class="headerlink" title="3、场景三：持续集成"></a><strong>3、场景三：持续集成</strong></h3><p>　　　　　　1. 一个项目版本快速迭代的测试场景，需要一个合理的CI（持续集成）/CD（持续部署）环境支撑。</p><p>　　　　　　2. CI/CD是一个周期性自动化项目测试流程，包括构建、部署、测试、发布等工作，很少需要人工干预。</p><p>　　　　　　3. Docker通过项目镜像构建和快速部署，打通测试环境与生产环境，高度保持多个环境之间一致性。</p><h3 id="4、场景四：微服务"><a href="#4、场景四：微服务" class="headerlink" title="4、场景四：微服务"></a><strong>4、场景四：微服务</strong></h3><p>　　　　　　1. 微服务指尽可能细粒度拆分业务程序架构，由多个独立服务组成业务系统。</p><p>　　　　　　2. Docker容器作为这些独立服务的部署单元，每个服务单独部署到一个docker容器中。</p><h2 id="一、docker的安装"><a href="#一、docker的安装" class="headerlink" title="一、docker的安装"></a>一、docker的安装</h2><pre><code class="hljs python"><span class="hljs-comment"># 1、安装依赖包</span>yum install -y yum-utils device-mapper-persistent-data lvm2<span class="hljs-comment"># 2、添加Docker软件包源(否则doker安装的不是新版本)</span>yum-config-manager \--add-repo \https://download.docker.com/linux/centos/docker-ce.repo<span class="hljs-comment"># 3、安装Docker CE</span>yum install -y docker-ce<span class="hljs-comment"># 4、启动Docker服务并设置开机启动</span>systemctl start dockersystemctl enable docker<span class="hljs-comment"># 5、测试docker是否安装成功（hello-world是官方提供的一个测试镜像）</span>docker run hello-world<span class="hljs-comment"># 6、查看docker基本信息</span>docker infodocker version</code></pre><h2 id="二、docker的简单使用"><a href="#二、docker的简单使用" class="headerlink" title="二、docker的简单使用"></a>二、docker的简单使用</h2><pre><code class="hljs python"><span class="hljs-comment"># 1、创建一个nginx容器</span>docker run -it nginx<span class="hljs-comment"># 2、查看docker运行的容器(可以获取到这个容器的id)</span>docker ps<span class="hljs-comment"># 3、访问这个容器</span><span class="hljs-comment"># 进入这个nginx容器（进入的文件系统和宿主机是完全隔离的，有自己独立的文件系统）</span>docker <span class="hljs-keyword">exec</span> -it <span class="hljs-number">73877e65</span>c07d bash<span class="hljs-comment"># 4、查看当前容器的 IP</span>docker inspect <span class="hljs-number">73877e65</span>c07d   <span class="hljs-comment"># 73877e65c07d是通过docekr ps查看到的容器ID</span>curl <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span>               <span class="hljs-comment"># 测试这个nginx容器是否可以访问</span></code></pre><h2 id="三、docker常用命令"><a href="#三、docker常用命令" class="headerlink" title="三、docker常用命令"></a>三、docker常用命令</h2><h3 id="1、docker镜像管理常用命令"><a href="#1、docker镜像管理常用命令" class="headerlink" title="1、docker镜像管理常用命令"></a><strong>1、docker镜像管理常用命令</strong></h3><pre><code class="hljs python">docker help                              <span class="hljs-comment"># 查看docker帮助</span>docker image --help                      <span class="hljs-comment"># 查看 docker中 镜像相关帮助</span>docker image ls                          <span class="hljs-comment"># 查看当前所有镜像</span>docker image inspect nginx               <span class="hljs-comment"># 查看指定镜像（nginx镜像）详细信息</span>docker pull nginx:<span class="hljs-number">1.14</span>                   <span class="hljs-comment"># 下载指定版本镜像 nginx</span>docker image rm nginx:<span class="hljs-number">1.14</span>               <span class="hljs-comment"># 删除nginx 1.14版本</span>docker image save nginx &gt; nginx.tar          <span class="hljs-comment"># 导出niginx镜像</span></code></pre><h3 id="2、docker创建容器常用命令"><a href="#2、docker创建容器常用命令" class="headerlink" title="2、docker创建容器常用命令"></a>2、docker创建容器常用命令</h3><pre><code class="hljs python"><span class="hljs-comment">#docker run 常用参数</span>-d:   后台运行容器，并返回容器ID；-i:   以交互模式运行容器，通常与 -t 同时使用；-t:   为容器重新分配一个伪输入终端，通常与 -i 同时使用；-P:   随机端口映射，容器内部端口随机映射到主机的高端口-p:   指定端口映射，格式为：主机(宿主)端口:容器端口--name=<span class="hljs-string">&quot;nginx-lb&quot;</span>:   为容器指定一个名称；--dns <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>:   指定容器使用的DNS服务器，默认和宿主一致；</code></pre><pre><code class="hljs python"><span class="hljs-comment">#docker run 其他参数</span>--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；-h <span class="hljs-string">&quot;mars&quot;</span>: 指定容器的hostname；-e username=<span class="hljs-string">&quot;ritchie&quot;</span>: 设置环境变量；--env-file=[]: 从指定文件读入环境变量；--cpuset=<span class="hljs-string">&quot;0-2&quot;</span> <span class="hljs-keyword">or</span> --cpuset=<span class="hljs-string">&quot;0,1,2&quot;</span>: 绑定容器到指定CPU运行；-m :设置容器使用内存最大值；--net=<span class="hljs-string">&quot;bridge&quot;</span>: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；--link=[]: 添加链接到另一个容器；--expose=[]: 开放一个端口或一组端口；--volume , -v:    绑定一个卷-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</code></pre><pre><code class="hljs python">docker run --help                               <span class="hljs-comment"># 查看创建容器帮助</span>docker run -it centos                           <span class="hljs-comment"># 创建centos镜像并进入终端</span>docker run -d nginx                             <span class="hljs-comment"># 后台启动nginx容器</span>docker stop <span class="hljs-number">6</span>bb09dce461f                    <span class="hljs-comment"># 关闭一个容器</span>docker ps -l                                    <span class="hljs-comment"># 查看最近运行的容器</span>docker run -itd centos                          <span class="hljs-comment"># 启用一个伪终端守护centos容器</span></code></pre><pre><code class="hljs python">docker container run -d --name web3 -e test=<span class="hljs-number">123456</span> -p <span class="hljs-number">8800</span>:<span class="hljs-number">80</span> -h webhostname --restart always nginx-d                                       <span class="hljs-comment"># 后台启动nginx容器</span>--name web3                              <span class="hljs-comment"># 自定义容器名字(默认会是一段随机字符串)</span>-e test=<span class="hljs-number">123456</span>                           <span class="hljs-comment"># 启动容器添加变量 test=123456 (echo $test)</span>-p <span class="hljs-number">8800</span>:<span class="hljs-number">80</span>                               <span class="hljs-comment"># 宿主机的8800端口映射到docker容器的80端口中</span>-h webhostname                           <span class="hljs-comment"># docker容器主机名 (a300f394af88)</span>--restart always                         <span class="hljs-comment"># 宿主机重启自动拉起这个docker容器</span>nginx                                    <span class="hljs-comment"># 使用这个nginx镜像启动容器</span><span class="hljs-comment">#注：http://192.168.56.12:8800/         访问这个docker  nginx</span></code></pre><h3 id="3、docker管理容器常用命令"><a href="#3、docker管理容器常用命令" class="headerlink" title="3、docker管理容器常用命令"></a>3、docker管理容器常用命令</h3><pre><code class="hljs python">docker ps                <span class="hljs-comment">#查看当前正在运行的容器</span>docker ps -a                <span class="hljs-comment">#查看已退出的容器</span>docker rm 容器id            <span class="hljs-comment">#删除容器</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7上安装MySQL</title>
    <link href="/2020/01/02/Centos7%E4%B8%8A%E5%AE%89%E8%A3%85MySQL/"/>
    <url>/2020/01/02/Centos7%E4%B8%8A%E5%AE%89%E8%A3%85MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云Centos7上安装MySQL教程"><a href="#阿里云Centos7上安装MySQL教程" class="headerlink" title="阿里云Centos7上安装MySQL教程"></a>阿里云Centos7上安装MySQL教程</h2><p>1.查看系统是否安装了mysql软件</p><pre><code class="hljs vala"><span class="hljs-meta"># rpm -qa|grep -i mysql</span></code></pre><p>2.将已经安装过的软件卸载掉。注意：这样的卸载是不彻底，不过这里够用了</p><pre><code class="hljs autoit"><span class="hljs-meta"># yum remove <span class="hljs-string">&#x27;软件名&#x27;</span></span></code></pre><p>3.<code>CentOS 7</code>的<code>yum</code>源中默认是没有<code>mysql</code>的。所以，为了解决这个问题我们首先下载安装<code>mysql</code>的<code>repo</code>源。</p><pre><code class="hljs 1c"><span class="hljs-meta"># wget http:<span class="hljs-comment">//repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm</span></span></code></pre><ol start="4"><li>安装<code>mysql</code>的<code>repo</code>源</li></ol><pre><code class="hljs css"># <span class="hljs-selector-tag">rpm</span> <span class="hljs-selector-tag">-ivh</span> <span class="hljs-selector-tag">mysql57-community-release-el7-7</span><span class="hljs-selector-class">.noarch</span><span class="hljs-selector-class">.rpm</span></code></pre><p>安装之后会获得<code>/etc/yum.repos.d/mysql-community.repo</code>和<code>/etc/yum.repos.d/mysql-community-source.repo</code>两个源，可以去相应的路径下查看一下。</p><p>5.开始安装</p><pre><code class="hljs vala"><span class="hljs-meta"># yum install mysql-server</span><span class="hljs-meta"># yum install mysql-devel</span><span class="hljs-meta"># yum install mysql</span><span class="hljs-meta"># rpm -qa | grep -i mysql</span></code></pre><p>6.服务开关操作</p><pre><code class="hljs vala"><span class="hljs-meta">#执行其中之一就可以</span><span class="hljs-meta"># service mysqld status     查看mysql当前的状态</span><span class="hljs-meta"># systemctl status mysqld</span><span class="hljs-meta"># service mysqld stop       停止mysql</span><span class="hljs-meta">#systemctl stop mysqld</span><span class="hljs-meta"># service mysqld restart    重启mysql</span><span class="hljs-meta">#systemctl restart mysqld</span><span class="hljs-meta"># service mysqld start      启动mysql</span><span class="hljs-meta"># systemctl start mysqld</span></code></pre><p>7.设置MySQL开机启动</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> systemctl <span class="hljs-built_in">enable</span> mysqld</span></code></pre><p>8.启动MySQL服务进程</p><pre><code class="hljs vala"><span class="hljs-meta"># systemctl start mysqld</span>或者<span class="hljs-meta"># service mysqld start</span></code></pre><h2 id="无法登录问题解决"><a href="#无法登录问题解决" class="headerlink" title="无法登录问题解决"></a>无法登录问题解决</h2><p><strong>1.在/etc/my.cnf文件中添加</strong><code>**skip-grant-tables。****这里注意一下：我的skip-grant-tables放到了文件最后**。</code></p><p><strong>skip-grant-tables：的作用就是跳过了mysql的用户验证</strong></p><p><strong>然后直接输入mysql，不需要带任何登录参数直接回车就可以登陆上数据库;</strong></p><p><strong>2.重启mysql，service mysqld restart，重启之后我们直接输入mysql即可进入mysql数据库，因为我们已经跳过了mysql数据库的用户验证。</strong></p><p><strong>进入数据库之后执行下面的命令</strong></p><pre><code class="hljs pgsql">mysql&gt; use mysql;mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>,authentication_string <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<span class="hljs-keyword">update</span> mysql.<span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string=<span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;your password&#x27;</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">&#x27;root&#x27;</span>;flush <span class="hljs-keyword">privileges</span>;<span class="hljs-keyword">exit</span></code></pre><p>3.<strong>恢复/etc/my.cnf文件</strong></p><p>恢复<code>/etc/my.cnf</code>，将<code>skip-grant-tables</code>删除或者注释掉。</p><p><strong>4.重启mysql，service mysqld restart</strong></p><p><strong>到此为止我们就解决了mysql安装之后登录不知道密码的问题。</strong></p><h2 id="MySql取消密码强度验证功能"><a href="#MySql取消密码强度验证功能" class="headerlink" title="MySql取消密码强度验证功能"></a>MySql取消密码强度验证功能</h2><blockquote><p>修改MySql配置文件（my.cnf）<br>一般情况下，MySql的配置文件 my.cnf 会在 /etc/ 目录下，如果没有，可以使用以下命令查找位置：<br>find / -name my.cnf<br>编辑配置文件：<br>vi /etc/my.cnf<br>在文件末尾添加以下内容：<br>plugin-load=validate_password.so<br>validate-password=OFF<br>保存退出</p></blockquote><p><img src="/2020/01/02/Centos7%E4%B8%8A%E5%AE%89%E8%A3%85MySQL/1.png"></p><p>**重启MySQL： systemctl restart mysqld.service **</p><h2 id="重置密码问题"><a href="#重置密码问题" class="headerlink" title="重置密码问题"></a><strong>重置密码问题</strong></h2><p>下面顺便讲解一下这个问题：</p><p>安装完mysql 之后，登陆以后，不管运行任何命令，总是提示这个错误：</p><p>You must reset your password using <strong>ALTER USER</strong> statement before executing this statement</p><p>处理步骤为：依次执行下面三条代码。</p><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&#x27;your new password&#x27;</span>);<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-keyword">EXPIRE</span> <span class="hljs-keyword">NEVER</span>;<span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;</code></pre><p>这里要注意的是your new password 必须包含数字，字母包含大小写，标点符号。不然好像是不能通过的。</p><p>完成以上三步退出再登，使用新设置的密码就行了，以上除了 your new password 需要修改成新密码外，其他原样输入即可。</p><h2 id="解决远程客户端无法连接MySQL数据库"><a href="#解决远程客户端无法连接MySQL数据库" class="headerlink" title="解决远程客户端无法连接MySQL数据库"></a><strong>解决远程客户端无法连接MySQL数据库</strong></h2><p><strong>1.创建新的安全组规则，对外开放3306端口访问授权</strong></p><p><strong>2.在本机登入mysql后,更改 “mysql” 数据库里的 “user” 表里的 “host” 项,从”localhost”改称’%’。</strong></p><pre><code class="hljs routeros">mysql -u root -pmysql&gt;use mysql;mysql&gt;select host,user <span class="hljs-keyword">from</span> user;mysql&gt;update<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">set</span> host = <span class="hljs-string">&#x27;%&#x27;</span> where<span class="hljs-built_in"> user </span>=<span class="hljs-string">&#x27;root&#x27;</span>;mysql&gt;flush privileges;mysql&gt;select host,user <span class="hljs-keyword">from</span> user;</code></pre><p>第一句是以权限用户root登录</p><p>第二句:选择mysql库</p><p>第三句:查看mysql库中的user表的host值(即可进行连接访问的主机/IP名称)</p><p>第四句:修改host值(以通配符%的内容增加主机/IP地址),当然也可以直接增加IP地址</p><p>第五句:刷新MySQL的系统权限相关表</p><p>第六句:再重新查看user表时,有修改</p><p>3.重起mysql服务即可完成。<strong>service mysqld restart</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>CenteOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos安装MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7关于网络的设置</title>
    <link href="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <url>/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>装好CentOS7后，我们一开始是上不了网的</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/1.png"></p><p>这时候，可以输入命令dhclient，可以自动获取一个IP地址，再用命令ip addr查看IP</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/2.png"></p><p>不过这时候获取的IP是动态的，下次重启系统后，IP地址也会变化，这时候我们可以把系统的IP设置为静态的，设置步骤如下：<br>（1）点击VMware虚拟机左上角的“编辑”，选择“虚拟网络编译器”。<br>（2）选中VMnet8（NAT模式），再点击右侧的“NAT设置”此时会看到如下界面</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/3.jpg"></p><p>（3）在命令行中输入：vim /etc/sysconfig/network-scripts/ifcfg-ens33</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/4.png"></p><p>（4）此时会进入如下图所示界面</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/5.png"></p><p>（5）将ONBOOT=no改为yes，将BOOTPROTO=dhcp改为BOOTPROTO=static,并在后面增加几行内容：<br>IPADDR=192.168.127.128<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.127.2<br>DNS1=119.29.29.29</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/6.png"></p><p>（6）保存后退出，然后输入命令：systemctl restart network.service来重启网络服务。</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/7.png"></p><p>（7）再用ip addr查看IP,并用命令ping测试网络的连通性。</p><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/8.png"></p><h4 id="设置ip段必须在起始和结束范围之内"><a href="#设置ip段必须在起始和结束范围之内" class="headerlink" title="设置ip段必须在起始和结束范围之内"></a>设置ip段必须在起始和结束范围之内</h4><p><img src="/2020/01/02/CentOS7%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E7%BD%AE/9.png"></p><p>至此，IP即设置完毕。</p>]]></content>
    
    
    <categories>
      
      <category>CenteOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos网络的设置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos中安装python3.7</title>
    <link href="/2019/12/30/centos%E4%B8%AD%E5%AE%89%E8%A3%85python3-7/"/>
    <url>/2019/12/30/centos%E4%B8%AD%E5%AE%89%E8%A3%85python3-7/</url>
    
    <content type="html"><![CDATA[<h4 id="1、安装依赖-amp-下载python3-7"><a href="#1、安装依赖-amp-下载python3-7" class="headerlink" title="1、安装依赖&amp;下载python3.7"></a><strong>1、安装依赖&amp;下载python3.7</strong></h4><pre><code class="hljs apache"><span class="hljs-comment"># 1、yum更新yum源</span><span class="hljs-attribute">yum</span> update<span class="hljs-comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span><span class="hljs-attribute">yum</span> install zlib-devel bzip<span class="hljs-number">2</span>-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make<span class="hljs-comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span><span class="hljs-attribute">wget</span> https://www.python.org/ftp/<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span>/Python-<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span>.tgz</code></pre><p><strong>2、安装Python</strong> </p><pre><code class="hljs awk"><span class="hljs-comment"># 1、yum更新yum源</span>yum update<span class="hljs-comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span>yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make<span class="hljs-comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span>wget https:<span class="hljs-regexp">//</span>www.python.org<span class="hljs-regexp">/ftp/</span><span class="hljs-number">3.7</span>.<span class="hljs-number">0</span>/Python-<span class="hljs-number">3.7</span>.<span class="hljs-number">0</span>.tgz　　<span class="hljs-number">2</span>、安装Python<span class="hljs-comment"># 1、解压</span>tar -xvf Python-<span class="hljs-number">3.7</span>.<span class="hljs-number">0</span>.tgz<span class="hljs-comment">#2、配置编译</span>cd Python-<span class="hljs-number">3.7</span>.<span class="hljs-number">0</span>.<span class="hljs-regexp">/configure --prefix=/u</span>sr<span class="hljs-regexp">/local/</span>python3  <span class="hljs-comment"># 配置编译的的路径（这里--prefix是指定编译安装的文件夹）</span>.<span class="hljs-regexp">/configure --enable-optimizations  # 执行该代码后，会编译安装到 /u</span>sr<span class="hljs-regexp">/local/</span>bin/ 下，且不用添加软连接或环境变量make &amp;&amp; make installln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/python3 /u</span>sr<span class="hljs-regexp">/bin/</span>python3  <span class="hljs-comment"># 添加软连接</span>ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin<span class="hljs-regexp">/pip3 /u</span>sr<span class="hljs-regexp">/bin/</span>pip3<span class="hljs-comment">#3、将/usr/local/python3/bin加入PATH</span>[root@linux-node1 testProj]<span class="hljs-comment"># vim /etc/profile</span><span class="hljs-comment">#然后在文件末尾添加</span>export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python3/</span>bin[root@linux-node1 testProj]<span class="hljs-comment"># source /etc/profile # 修改完后，还需要让这个环境变量在配置信息中生效，执行命令</span></code></pre><h4 id="3-创建python虚拟环境"><a href="#3-创建python虚拟环境" class="headerlink" title="3,创建python虚拟环境"></a>3,创建python虚拟环境</h4><pre><code class="hljs mel"><span class="hljs-number">1</span>、安装virtualenv　　　　　　yum install <span class="hljs-keyword">python</span>-virtualenv　　<span class="hljs-number">2</span>、创建<span class="hljs-keyword">python</span>虚拟环境　　　　　　virtualenv <span class="hljs-keyword">env</span>           # 执行后，在本地会生成一个与虚拟环境同名的文件夹　　　　　　如果你的系统里安装有不同版本的<span class="hljs-keyword">python</span>，可以使用--<span class="hljs-keyword">python</span>参数指定虚拟环境的<span class="hljs-keyword">python</span>版本：　　　　　　virtualenv --<span class="hljs-keyword">python</span>=/usr/local/python3/bin/python3 <span class="hljs-keyword">env</span>　　<span class="hljs-number">3</span>、启动虚拟环境　　　　　　　　　　<span class="hljs-keyword">source</span> bin/activate         # 启动虚拟环境　　　　　　deactivate                      # 退出虚拟环境</code></pre>]]></content>
    
    
    <categories>
      
      <category>CenteOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>centos中安装python3.7</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
